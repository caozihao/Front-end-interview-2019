##  Http

### 概念：

超文本传输协议：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少

### http的缺点：

* 通信使用明文（不加密），内容可能会被窃听
* 不验证通信方的身份，因此有可能遭遇伪装
* 无法证明报文的完整性，所以有可能已遭篡改

### http1.0，1.1，2.0的区别
* 1.0
  * 链接无法复用，即不支持持久链接
    * 浏览器每次请求都和服务器经过三次握手和慢启动来建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，而不跟踪每个浏览器的历史请求
  * 线头阻塞
    * 请求队列的第一个请求因为服务器正忙（或请求各式等其他问题），导致后面的请求被阻塞
* 1.1
  * 支持持久链接（在request和response中的header中的connection是close或者keep-alive进行控制）
    * 一个TCP链接可以传送多个http请求和相应，减少了TCP建立链接和关闭链接的消耗。
    * 允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。    
  * 增加请求头和响应头来扩充功能
    * 支持Host请求：
    * Connection: 请求头的值为Connection时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close 时，客户端通知服务器返回本次请求结果后关闭连接
    * 支持断点续传
    * 身份认证
    * 状态管理
    * 缓存处理
      *cache-control
      *Expires
      *Last Modified
      *Etag
    * http2.0
      * 支持多路复用
        * 多路复用允许同时通过单一的 HTTP 2.0 连接发起多重的请求（即所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可）
        * 所有数据流共用同一个连接 ，减少了因http链接多而引起的网络拥塞
        * 解决了慢启动针对突发性和短时性的http链接低效的问题。
      * 支持http管道
      * 使用多个TCP链接
      * 将通信的基本单位缩小为帧
        *  即应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层，因此在多向请求和响应时，客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来，解决了http 1.*的对手阻塞问题。 
      * 首部压缩
        * http 2.0支持DEFLATE和HPACK 算法的压缩。
      * 服务端推送
        *  指客户端请求之前发送数据的机制，在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应。


参考文章：https://blog.csdn.net/zhglance/article/details/76162176

###  https：

* http + 加密 + 认证 + 完整性保护 = https                    * 是以安全为目标的http通道，简单来讲就是http的安全版，即在http下加入SSL层，https的安全基础是SSL（Secure Sockets Layer）
*  http协议的主要作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性
* 缺点：
  * 握手阶段比较非十，会使页面加载时间延长50%，增加10%~20%的耗电
  * 缓存不如http高效，会增加数据开销
  * SSL证书需要钱，功能越强大，证书费用越高
  * 需要绑定IP，不能在同一个IP上绑定多个域名



### http状态码

* 1xx:（信息性状态码）接受的请求正在处理
* 2xx:（成功状态码）请求正常处理完毕
  * 200：请求正常处理
  * 204：请求处理成功，但是没有资源可返回
  * 206：对某一资源的部分请求 （解决大文件下载问题，
解决CDN和原始HTTP服务器问题）

* 3xx:（重定向状态码）需要进行附加操作已完成请求
  * 301：永久性重定向，请求的资源的URL(Uniform Resource Identifier,标识)已更新，以后应该使用现在所指的URI 
    * 301比较常用的场景是使用域名跳转。（baidu.com ->https://www.baidu.com/）
  * 302：临时性重定向，请求的资源URI已更新，希望能用新的URI访问
    * 比如未登陆的用户访问用户中心重定向到登录页面。
　　* 访问404页面会重新定向到首页。 
  * 303：表示请求的资源存在着另一个URI，应使用GET方法重定向获取请求的资源
    * 303状态码和302状态码有着相同的功能，但是303状态码明确表示客户端应该采用GET方法获取资源
    * HTTP/1.1以前的浏览器不能正确理解303
    * 现在很多现存的浏览器将302响应视为303，并且使用GET请求，而无视原先请求的方法
    * 301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改为GET，并删除请求报文内的主题，之后请求会自动再次发送
    * 301，302标准是禁止将POST方法改为GET方法的，但实际应用时大家都会这么做
  * 304：服务端资源未改变，可直接使用客户端未过期的缓存
  * 307：临时性重定向。和302有着相同的含义，尽管302标准禁止POST改为GET，但是实际使用时大家并不遵守
    * 会遵照浏览器标准，不会从POST改为GET，但是对于处理响应时的新闻给，每种浏览器有可能出现不同的情况

* 4xx:（客户端错误状态码）服务器无法处理请求
  * 400：服务器不理解请求的语法，请求报文中出现语法错误
  * 401：未授权，请求要求身份认证，对于登录后请求的网页，服务器可能返回此响应
  * 403：请求资源被服务器拒绝
  * 404：服务器上没有请求的资源
* 5xx:（服务端错误状态码）服务器处理请求出错
  * 500：服务器内部错误
  * 503：服务器暂时处于超负载或正在进心停机维护

### TCP/IP
  * 概念：把互联网关联的协议集合起来总称为TCP/IP
  * 分层：应用层，传输层，网络层，数据链路层
    * 应用层（DNS,FTP，http协议）
    * 传输层（TCP,UDP）
    * 网络层（IP）
    * 链路层（用来处理连接网络的硬件部分）
  * TCP/IP 通信传输流
    * 发送端从应用层往下走，接收端从链路层往上走
    * 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。
    * 接收端在层与层之间传输数据时，每经过一层时会把对应的首部消去

### 三次握手协议       
  * 第一次：客户端向服务端发送一个SYN包，此时客户端进入SYN_SENT状态
  * 第二次：服务端向客户端发送一个SYN/ACK包，此时服务端进入SYN_RECV状态
  * 第三次：客户端向服务端发送一个ACK包，客户端和服务端同时进入  ESTABLISHED ,完成三次握手               

### Websocket

  * websocket是HTML5中的协议，是一种在单个TCP连接上进行全双工通信的协议，支持持久连接，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个

### get / post 区别

#### 语义上的区别

请求方式|GET|POST
-|-|-
参数位置|通过URL传递|放在Request body中
参数大小|受限于浏览器url大小，一般不超过32k|无限制 
安全性|多数携带在url中，安全性低|相对于GET请求，安全性更高
行为|获取数据|提交数据
书签|可收藏为书签|不可收藏为书签
历史|参数保留在浏览器历史中。|参数不会保存在浏览器历史中
幂等性|幂等|不幂等
编码类型|application/x-www-form-url|encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
数据类型|只允许ASCII字符|没有限制，也允许二进制数据


**幂等性：
* 同一个请求发送多次和仅执行一次的效果完全相同
* 按照RFC规范，PUT，DELETE和安全方法都是幂等的，服务端实现是否幂等是无法确保的。
* 引入幂等主要是为了处理同一个请求重复发送的情况
* 比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。


####  语法上的区别
* GET和POST是http协议中两种发送请求的方式，而http是基于TCP/IP协议的的关于数据如何在万维网中通信的协议
* HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 
* GET产生一个TCP数据包，而POST在数据量大的时候会产生两个TCP数据包
* 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200
* 对于POST，浏览器先发header，服务器响应100，然后再发送data，服务器响应200
* 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点


参考文章(https://www.cnblogs.com/logsharing/p/8448446.html)
(https://www.cnblogs.com/logsharing/p/8448446.html)


### Websocket

### TCP三次握手     
建立连接前，客户端和服务端需要通过握手来确认对方:

* 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认
* 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态
* 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态

### TCP四次握手

* 客户端 --FIN --> 服务端，FIN--WAIT
* 服务端 --ACK --> 客户端，CLOSE-WAIT
* 服务端 --ACK,FIN -->客户端，LAST-ACK
* 客户端 --ACK -->服务端，CLOSED

### Node 的 Event Loop: 6个阶段

### Node的Event Loop：6个阶段

* timer阶段：执行到期的 setTimeout  / setInterval 队列回调
* I/O阶段：执行上轮循环残留的callback
* idle，prepare
* poll：等待回调
  * 1，执行回调
  * 2，执行定时器
    * 如有到期的 setTimeout / setInterval.则返回Timer阶段
    * 如有 setImmediate,则前往check阶段
  * check
    * 执行setImmediate
  * close callbacks