## 1. 原型 / 构造函数 / 实例
* 原型
  *  一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。
* 构造函数
  * 可以通过new来 新建一个对象 的函数。
* 实例
  * 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。

* 三者关系
  ```
 // 实例
  const instance = new Object()

  // 原型
  const prototype = Object.prototype

  实例._proto_ === 原型
  原型.constructor === 构造函数
  构造函数.prototype === 原型

  ```

## JS 堆栈区别
  * 栈（stack）：是一种后进先出的数据结构
  * 堆（heap）：是一种先进先出的数据结构

* 二者存储的数据类型和处理速度不同：
  * 栈：主要存放一些基本类型的变量和对象的引用，由系统自动释放
  * 堆：用于复杂数据类型（引用类型）分配空间，比如数组，object对象。是动态分配内存的，大小不定，也不会自动释放

 ## 垃圾回收机制
  * 标记清楚算法：  
    * 垃圾回收期生成一个根列表，根通常是引用保存在代码中的全局变量，在js中，window对象是一个可以作为根的全局变量    
    * 所有根都被检查和标记为活跃的，所有的子变量也被递归检查，所有可能从根元素到达的都不被认为是垃圾 
    * 所有没有被标记为活跃的内存都被认为是垃圾，垃圾回收期可以释放内存并且把内存还给操作系统

   * 垃圾回收期的反常行为    
    垃圾回收期的不确定性，是不可预测的，你不知道垃圾回收期会在什么时候被执行，在一些敏感的应用程序中，可能会出现短暂停顿。大多数人GC都会在分配内存的期间启动收集例程，如果没有分配内存，大部分垃圾回收就保持空闲

##  ES6/ES7
* 声明
  * let / const:块级作用域，不存在变量提升，暂时性死区，不允许重复声明
  * const: 声明常量。无法修改
* 解构赋值
* class / extend: 类声明与继承
* Set / Map: 新的数据结构
* 异步解决方案:
  * Promise的使用与实现
  * yield: 暂停代码
  * next(): 继续执行代码

##  AST(抽象语法树)
* 是将代码逐字母解析成树状结构的形式
* 过程主要有两步
  * 词法分析(也叫做扫描scanner)。
    * 它读取我们的代码，然后把它们按照预定的规则合并成一个个的标识tokens。
    * 同时，它会移除空白符，注释，等。
    * 最后，整个代码将被分割进一个**tokens列表（或者说一维数组）**。
  
 * 语法分析(也叫做解析器)
   * 它会将词法分析出来的数组转化成树形的表达形式。同时，验证语法，语法如果有错的话，抛出语法错误。


##   babel编译原理
* babylon将ES6/ES7 代码解析成 AST
* babel-traverse对AST进行遍历转移，(替换、移除和添加节点),得到新的AST
* 其中用到了babel-types,是一个类Lodash式工具库，包含了构造、验证以及变换 AST 节点的方法
* 新AST 通过babel-generator 转换成ES5

##  函数柯里化

* 定义
  * 函数柯里化就是把接受多个参数的函数变成接受一个单一参数的函数，并且返回接受余下参数且返回结果的新函数的技术
  * 函数柯里化的运行过程其实就是一个参数的收集过程，将每一次的参数收集起来，并在最里层处理    
  * 函数柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如

* 柯里化的特点
  * 一个闭包保存参数，一个函数来进行递归

* 闭包和柯里化的区别
  * 区别在于返回的函数中还附带参数。

* 使用场景
  * 减少重复传递不变的部分参数
  * 兼容浏览器事件监听方法
  * 防抖和函数节流
  * 兼容低版本IE的bind方法

* 通用代码
  ```
  function commonCurry(func){
    var args = [].slice.call(arguments,1);

    var _func = function(){
      [].push.apply(args,arguments);
      return _func;
    }

    _func.toString = function(){
      return func.apply(this,args);
    }
    return _func;
  }
  

  ```

##  反柯里化
  * 作用在于扩大函数的适用性，使本来作为对象所拥有的功的能函数可以被任意对象所用，通过借用泛化、扩大了函数的使用范围。

  ```
  var unCurring = function(fn){
    return function(){
      var args = [].slice.call(arguments,1);
      return fn.apply(arguments[0],args);
    }
  }

  ```