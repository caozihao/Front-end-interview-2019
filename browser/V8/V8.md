##  google V8引擎

####  介绍

v8引擎是一种js引擎的实现，（由google开发，用c++编写），js引擎是执行js代码的程序或解释器，js引擎可以实现为标准解释器或即时解释器，它以某种形式将js编译为字节码


#### 其他浏览器也有自己的引擎引擎

Mozilla，Firefox，Safari

####  如何提高性能

v8会把js代码转换为高效的机器码，而不是依赖于解释器去执行，v8引入了JIT(即时编译技术)，在运行时把js代码进行转换为机器码，v8不生成字节码或任何中间代码

####  JIT即时编译

* 步骤：JS源码 ->AST抽象语法树-本地机器码
* 优点：比起生成中间码解释执行的方式，V8的策略省去了一个步骤，程序会更早的开始运行。并且执行编译好的机器指令，也比解释执行中间码的速度更快。
* 缺点：缺少字节码这个中间表示，使得代码优化变得更困难了。

####  V8有哪些进程

* 主进程负责获取代码，编译生成机器码
* 专门负责优化的进程
* 监控进程负责分析那些代码执行比较慢，以遍优化
* GC进程。负责垃圾回收

####  v8的优化方法
* 尽可能最大的内联
  内联主要是通过优化被调用函数的调用栈
* 优化隐藏类
  * js中并没有指针的概念，js的对象访问就是基于隐藏类的。
  * 隐藏类转换取决于将属性添加到对象的**顺序**
  * 最好采用相同的初始化顺序，以便系统可以复用隐藏类，帮助系统提升性能。
* 内联缓存
  * 内联缓存依赖于对相同方法的服用，倾向于在相同类型的对象上发生的观察
  * v8在执行一个对象的方法时，会通过查找隐藏类确定偏移量，然后去执行，在两次成功调用后，v8会假定对象不变，再次调用时直接利用偏移量去访问，而不在去做隐藏类查找，这极大的提升了运行速度，这也是为什么在初始化对象时，最好保证相同的顺序。如果两个对象使用不同的隐藏类，内联缓存则无法应用
* Compilation to machine code
  * V8之前的优化，是基于某种假设。如果假设失败，v8会启动一种为 deoptimization 的行为，重新去分析。这种行为的成本很高，所以要尽量避免。
* 垃圾回收机制（GC）  

####  了解v8引擎内部运作原理，如何编写优化的js

* 以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码
* 在实例化之后向对象添加属性将强制隐藏类更改，并放慢为以前隐藏类优化的所有方法，相反，在其构造函数中分配所有对象的属性

* 重复执行相同方法的代码将比仅执行一次（由于内联高速缓存）执行许多不同方法的代码运行得更快

* 避免键数不是增量数的稀疏数组，稀疏数组中没有每个元素都是哈希表，这种阵列中的元素访问费用较高，另外，尽量避免预分配大型数组。随着你的成长，你的成长会更好。最后，不要删除数组中的元素。


[参考文章](https://www.jianshu.com/p/81f6ded64ab2)
 
