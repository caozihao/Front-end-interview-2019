##  2. 浏览器架构
* 用户界面
* 主进程
* 内核
    * js渲染引擎
      * JS执行栈（后进先出）
    * 事件触发线程
      * 消息队列
        * 宏任务
        * 微任务
    * 定时器线程
    * 网络异步线程
    * I/O线程

##  3. 浏览器下事件循环(Event Loop)
  事件循环是指：执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务。在清微任务列表  

* 微任务：microtask(jobs):promise/process.nextTick/Object.observe
* 宏任务:macrotask(tasks):setTimeout/setImmediate/setInterval/I/O/UI rending/script(整体代码)

##  4.从输入url到展示的过程

* DNS解析
* TCP三次握手
* 发送请求，分析url，设置请求报文（头，主题）
* 服务器返回请求的文件（html）
* 浏览器渲染
  * HTML parser ->DOM Tree
    * 标记化算法，进行元素状态的标记
    * dom数的构建
  * CSS parser -> Style Tree
    * 解析 css 代码，生成样式数
*  attachment -->Render Tree
  *   综合dom树与style树，生成渲染树
*  layout布局
*  GPU painting：像素绘制页面  


*标记化算法：
**标记化算法的输出结果是HTML标记**，该算法使用状态机来表示，每一个状态接受来自输入信息流的一个或多个字符串，并更具这些字符更新下一个状态，当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接受的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态，该算法相当复杂，无法在此详述。

```
<html>
  <body>
    Hello world
  </body>
</html>
```
初始状态是**数据状态**。遇到字符 < 时，状态更改为“**标记打开状态**”。接收一个a-z字符会创建“**起始标记**”，状态更改为“**标记名称状态**”。这个状态会一直**保持到接收 > 字符**。在此期间接收的每个字符都会附加到新的标记名称上。

##  重绘与回流

当页面的样式发生变化时，浏览器需要触发更新，重新绘制元素，过程中，有两种类型操作，即重绘和回流

### 重绘  

当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少

### 回流

当元素的尺寸，结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作

页面初次渲染
浏览器窗口大小改变
元素尺寸、位置、内容发生改变
元素字体大小变化
添加或者删除可见的 dom 元素
激活 CSS 伪类（例如：:hover）
查询某些属性或调用某些方法

clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()


**回流必定发生重绘，重绘不一定触发回流，重绘的开销较小，回流的代价较高**

####  最佳实践：

* css
 
  * 避免使用table布局
  * 将动画效果应用到position属性为absolute或fixed的元素上

* js

  * 避免频繁操作样式，可汇总后统一 一次修改
  * 尽量使用class进行样式修改
  * 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入
  * 极限优化时，修改样式可将其display: none后修改
  * 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住


##  存储

分为短暂性存储，持久性存储

* 短暂性，将数据存储在内存中，只在运行时可用
* 持久性存储，分为浏览器端与服务端
  * 浏览器
    * cookie：通常用于存储用户身份，登录状态等
      * http中自动携带，体积上限为4k，可自行设置过期时间
    * localstorage/sessionstorage：长久储存/窗口关闭删除，体积限制为 4~5M
    * indexDB (浏览器提供的本地数据库,NoSql)
  * 服务器：
    * 分布式缓存 redis
    * 数据库

##  Web worker
    
    现代浏览器为js创造的多线程环境，可以新建并将部分任务分配到worker并行运行，两个线程可独立，互不干扰
    可通过自带的消息机制相互通信.

    web worker 是运行在后台的 JavaScript，不会影响页面的性能。

    所有主流浏览器均支持 web worker，除了 Internet Explorer。

### 限制

* 同源限制
* 无法使用 document / window / alert / confirm
* 无法加载本地资源

### 使用场景
* 大数据的处理：
这里所说的大数据处理，并不是指数据量非常大，而是要从计算量来看，通常用时不能控制在毫秒级内的运算都可以考虑放在web worker中执行。

* 高频的用户交互：
高频的用户交互适用于根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等类似场景，用户频繁输入的响应处理同样可以考虑放在web worker中执行。

##  结论

web worker不等同于后台意义的多线程，web worker现在有了多线程的形（有了多线程的用法），但还不具备多线程的神（不具备线程通信、锁等后台线程的基本特性。

web worker的本质是支持我们把数据刷新与页面渲染两个动作拆开执行（不使用web worker的话这两个动作在主线程中是线性执行的）。


##  V8垃圾回收机制

垃圾回收：将内存中不再使用的数据进行清理，释放出内存空间，V8将内存分成新生代空间和老生带空间

* 新生代空间：用于存活较短的对象
  * 又分成两个空间：from 空间与to空间
  * Scavenge GC算法：当from空间被占满时，启动GC算法
    * 存活的对象从from space 转移到 to Space
    * 清空 from space
    * from space 与to space互换
    * 完成一次新生代GC
* 老生带空间：用于存活时间较长的对象
  * 从新生代空间转移到老生带空间的条件
    * 经历过一次以上Scavenge GC的对象
    * 当to space体积超过25%
  * 标记清楚算法：标记存活的对象，未被标记的则被释放
    * 增量标记：小模块标记，在代码执行间隙，GC会影响性能
    * 并发标记（最新技术），不阻塞js执行
  * 压缩算法：将内存中清楚后导致碎片化对象往内存堆的一端移动，解决内存的碎片化

  ## 内存泄露

  垃圾回收语言中的泄漏的主要原因是不必要的引用

  * 意外的全局变量：无法被回收
  * 定时器：未被正确关闭，导致所引用的外部变量无法被释放
  * 事件监听：没有正确销毁（低版本浏览器可能出现）
  * 闭包：会导致父级中的变量无法被释放
  * dom 引用：dom元素被删除时，内存中的引用未被正确清空

  可用chrome中的timeline进行内存标记，可视化查看内存的变化情况，找出异常点